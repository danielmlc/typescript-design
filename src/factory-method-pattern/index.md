# 工厂方法模式 (Factory Method Pattern)

## 意图

**工厂方法模式**是一种创建型设计模式，它提供一个用于创建对象的接口，但让子类决定实例化哪一个类。工厂方法让一个类的实例化延迟到其子类。

换句话说，它定义了一个创建对象的“工厂”方法，但把具体创建什么对象的决定权交给了子类。

## 场景

想象一个物流管理应用。最初，你可能只支持卡车运输。但随着业务发展，你需要加入轮船运输，未来可能还有飞机运输。

如果你在代码中直接实例化 `Truck` 对象 (`new Truck()`)，那么每当需要引入新的运输方式时，你就必须去修改所有创建 `Truck` 的地方。这违反了“对修改关闭，对扩展开放”的原则。

工厂方法模式通过引入一个抽象的“物流”类 (`Logistics`) 和一个抽象的 `createTransport()` 方法来解决这个问题。`Logistics` 类负责计划运输，但它并不知道具体的运输工具是什么。具体的运输工具由它的子类（如 `RoadLogistics` 和 `SeaLogistics`）来创建。这样，当需要添加新的运输方式时，我们只需要创建一个新的 `Logistics` 子类，而无需修改现有的客户端代码。

## 结构

1.  **产品 (Product)**: (`Transport` 接口)
    *   定义了工厂方法所创建的对象的接口。

2.  **具体产品 (Concrete Product)**: (`Truck`, `Ship` 类)
    *   实现了产品接口，是工厂方法实际创建的对象。

3.  **创建者 (Creator)**: (`Logistics` 抽象类)
    *   声明了工厂方法 `createTransport()`，该方法返回一个产品对象。
    *   创建者还可以定义一个调用工厂方法的核心业务逻辑方法（如 `planDelivery`）。

4.  **具体创建者 (Concrete Creator)**: (`RoadLogistics`, `SeaLogistics` 类)
    *   重写（实现）工厂方法，以返回一个具体产品的实例。

## 优点

*   **开闭原则**: 你可以在不修改现有客户端代码的情况下引入新的产品类型。
*   **单一职责原则**: 你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。
*   **松耦合**: 创建者和具体产品之间的耦合度降低了。创建者只关心产品接口，不关心具体实现。

## 如何运行示例

你可以通过以下命令来运行这个 TypeScript 示例：

```bash
npx ts-node src/factory-method-pattern/index.ts
```